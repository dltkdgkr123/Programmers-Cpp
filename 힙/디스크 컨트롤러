/* 실행시간 기준 오름차순 정렬 후, 삽입시간 기준 오름차순 정렬한다.
삽입시간이 낮은 것을 우선순위로 하는 큐에 삽입시간보다 런타임이 더 지났을때 push하여 처리한다.

런타임과 사용시간을 따로 생각해야하며, 런타임동안 아무것도 삽입되지않았을 경우를 고려해야한다.

sort()와 우선순위큐 차이
함수구조체 less반대 리턴반대

정렬을 두번하고 우선순위큐에 집어넣으므로 비효율적이며 vector를 erase할 시, 사이즈가 커지면 뒤의 원소들을 앞으로 옮김에 따라 실행시간이 길어지므로
사용을 지양해야한다. -> 다른 알고리즘 필요

구현 중 for(int i=0;jobs.size();i++){jobs.erase(..)}; for(int i=0;q.size();i++){q.pop()}; 과 같은 코드를 썼었는데,
원소가 삭제됨에 따라 사이즈로 줄어듦으로, 원소의 누락이 발생되므로 사용하지 않아야 한다.
*/


#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

bool compare(vector<int> a, vector<int> b)
{
    if (a[0] = b[0])
        return a[1] < b[1];

}

struct compare2
{
    vector<int> a;
    vector<int> b;

    bool operator()(vector<int>a, vector<int> b)
    {
        return a[1] > b[1];
    }
};

int solution(vector<vector<int>> jobs) {
    priority_queue<vector<int>, vector<vector<int>>, compare2> q;
    int answer = 0;
    int runtime = 0;
    int time = 0;
    int jobs_size = 0;
    
    jobs_size = jobs.size();
    
    sort(jobs.begin(), jobs.end(), compare);
    sort(jobs.begin(), jobs.end());
    
    while (!jobs.empty() || !q.empty())
    {
        
        while(!jobs.empty())
        {
            if (runtime >= jobs[0][0])
            {
                q.push(jobs[0]);
                jobs.erase(jobs.begin());
                
            }
            else break;
        }
        
        if(q.empty())
        {
            q.push(jobs[0]);
            jobs.erase(jobs.begin());
            time += q.top()[1];
            runtime = q.top()[0] + q.top()[1];
            q.pop();
        }
        else
        {
            time += ((runtime - q.top()[0]) + q.top()[1]);
            runtime += q.top()[1];
            q.pop();
        }
    }

    answer = time / jobs_size;

    return answer;
}
