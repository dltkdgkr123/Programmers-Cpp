/*


소수 : 1과 자기 자신으로만 나누어떨어지는 수

맨 앞 0일때 예외처리

find() #include <algorithm>에 포함됨에 주의
 v.find(...) 가 아닌 find(...)에 주의 
 
반복문에서 dfs 쓸 때 항상 재귀호출 후 현상유지 시켜야함에 주의
 
 
 소수판별 https://jm-park.github.io/algorithm/2018/08/06/Prime-Number(%EC%86%8C%EC%88%98)-%ED%8C%90%EB%B3%84%EB%B2%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html
1. pow/sqrt 제곱수/제곱근 구하는 함수 사용
2. 에라토스테네스의 체 사용

정렬 후 만들어지는 가장 큰 수를 찾은 후, 그 소수 내에서 일치여부만 확인
그 수보다 작은 소수들을 구한 후, 만들어지는 numbers의 조합들과 비교
 
 
*/






/*

실행시간 초과 코드


#include <string>
#include <vector>
#include <unordered_set>
#include <algorithm>

using namespace std;

unordered_set<string> sosu;

bool is_true(float n) // (int)a -> (float)a 소수인지 확인하는 함수
{
    bool b = true;

    for (int i = 2; i < n; i++) // 소수n : 2부터 n-1까지 나누었을 때 나머지가 0이 아님
    {
        
        if ((n/i - (int)n/i) == 0) // (float)x - (int)x == 0 -> 나머지가 0이면
        {
            b = false;
            break;
        }
    }
    return b;
}


void dfs(string& numbers, vector<int> v, string s)
{

    for (int i = 0; i < numbers.length(); i++)
    {
        if (find(v.begin(), v.end(), i) != v.end()) // i번쨰를 사용하지 않았으면
            v.push_back(i); // i를 사용했다고 표시하고
            s += numbers[i]; // s에 숫자를 더함

        if (is_true(stof(s)) == true) // int s가 소수이면
            sosu.insert(s); // set에 insert -> 중복제거 위해 set 사용

        dfs(numbers, v, s); //dfs 실행
        v.pop_back();  // 다음 반복을 위해 최근 추가한 값 제거
        s.erase(s.end());
    }

}

int solution(string numbers) {
    int answer = 0;
    vector<int> v;

    dfs(numbers, v, "");

    unordered_set<string>::iterator iter = sosu.begin();

    for (auto iter = sosu.begin(); iter != sosu.end(); iter++)
        answer++;

    return answer;
}

*/
